[{"slug":"Appium","title":"Appium + Java 实现的小程序自动化测试框架搭建","description":"入公司以来第一个自己挑框架自己设计独立搭建起来的项目，本篇类似实战记录，记录踩过的坑","body":" 这项目是我入公司以来第一个自己挑框架自己设计独立搭建起来的项目，本篇类似实战记录，记录踩过的坑。\r\n\r\n> 背景是为了能够自动化测试一个特定小程序的基本功能，云测试平台有类似的功能测试，看官方给出的样例工程，实际上也是搭建一个基于 appium 的工程。我想着既然如此就干脆自己搭一个了，还能定制些自己喜欢的功能。\r\n> 以前做过 JAVA web 应用的自动化测试，使用的是 selenium，而 Appium 实际上我个人理解就是个手机端应用使用的 selenium 框架，底层实现，代码使用上，都跟 selenium 差不多。\r\n\r\n 这是一篇基于 appium 和 java 搭建的文章  https://www.swtestacademy.com/appium-tutorial/(https://www.swtestacademy.com/appium-tutorial/)，我整个项目的搭建也是受这篇文章的启发，写的还是很详细的。里面甚至还有安卓环境的搭建，JAVA 环境的搭建。\r\n\r\n下面以我的小程序自动化测试为例，运行在真机的 apk 上说明怎么搭建：\r\n\r\n先说一下 Appium 的使用 ：\r\n\r\n想体验 appium 的能力，最直观的就是使用一个他的可视化工具：appium desktop => https://www.electronjs.org/apps/appium(https://www.electronjs.org/apps/appium)\r\n\r\n!(/images/appium/appium-desktop.png)\r\n\r\n下载完成启动之后的页面如上图，点击 start server 就能在本地起他的 appium 服务，起来之后会进入一个类 DOS 的页面，这个里面会打印 appium 后台执行过程中的所有信息，报错日志什么的也在这里查看。\r\n\r\n!(/images/appium/appium-server.png)\r\n\r\n点击 start inspector session，就能进入一个更详细的配置页面，这个页面配置的就是希望拉起的 app 信息了。记得点击上面导航栏的 server，选择服务器。我个人都是在本地启动，所以选的都是 automatic server，默认就是在前面配置的 4723 端口上的服务。\r\n\r\n!(/images/appium/appium-session.png)\r\n\r\n而下面的 Capabilities 页面，就是待启动的 APP 信息配置页了，一般来说会有这些参数需要配置：以下信息我都是以真机为例，但安卓模拟器也是同理。\r\n\r\nplatformName => 平台名称，例如我这里的真机环境是安卓\r\n\r\nplatformVersion => 平台版本，例如这个真机的版本是 android 9 ，就直接填 9\r\n\r\ndeviceName => 真机的设备名称，一般在自己手机设置页看就能看到了\r\n\r\nappActivity 和 appPackage 是要重点说的：\r\n\r\n这两个参数的意义是你待拉起的 APP 的“包名”和“第一个访问的活动类”。例如我这里的测试 APK，是 Welink-UAT 这个 apk。\r\n\r\n在真机上先运行 welink-uat，用 adb 这个命令：\r\n\r\n\r\nadb shell \"dumpsys window w|grep \\\\/|grep name=|sed 's/mSurface=Surface(name=//g'|sed 's/)//g'|sed 's/ //g'\"\r\n\r\n\r\n可以查看到如下信息 ：\r\n\r\n!(/images/appium/exp1.png)\r\n\r\n红框内 com.huawei.works.uat/huawei.w3.MainActivity 就分别是我的包的 appPackage 和 appActivity；\r\n\r\n但是。如果你按照这个配置，启动 appium 时，会报 Permission denial \\*\\*\\*\\*的错误。这是因为 appActivity 指定的 MainActivity，并不是打开 Welink-UAT 时的第一个活动类。\r\n\r\n原因简单来说，MainActivity 可能是他的主类，在前面，你还需要登录（LoginActivity），但是你却没有登录就想直接访问 Main 了，肯定是不被允许的。\r\n\r\n并且，值得注意的是，appium 每次拉起一个 App，都会将原数据全部清空，重新拉起。\r\n\r\n所以在找正确的 appActivity 时，自己要手动清除数据，从零拉起这个 APP 来找第一个正确的类，例如 Welink-UAT 的第一个类就是一个广告页的类：huawei.w3.ui.welcome.W3SplashScreenActivity。\r\n\r\n配置好之后点击 Start session，一切正常的话，就会看到在真机上，welink-uat 被自动打开了，并且停在第一个广告页面。同时 appium 也弹出了一个新窗口：\r\n\r\n!(/images/appium/exp2.png)\r\n\r\n这个页面就是后面开发过程中会经常用到的页面了。左边是真机的当前页面，中间是个 DOM 页面，右边则是当前元素的一些信息。最上边的各类按钮使用起来也很方便，有选择元素，根据坐标点击，滑动等等的操作。最常用到的应该就是选择元素了，例如这个页面里，我选择了右下角弹出的这个权限窗口的确认按钮。\r\n\r\n很明显这里在代码中，我需要写一段代码，找到这个确认按钮的元素，点击赋权。右边的这个窗口就很方便的提供了他的定位信息。\r\n\r\n这个信息里是 id,xpath 还是 name 等等，完全取决于你的小程序或者 APK 的代码了。\r\n\r\n这里有个原则，**在定位元素时，能使用 id/name 就不要用 xpath**。xpath 确实会引入很多问题，并且当你的窗口结构变化时，xpath 也会随之变化。\r\n\r\n JAVA 后台框架：\r\n\r\n用 appium 来搭建自动化，后台框架的选择其实是很多样的，我就认识另外一个测试同事使用的是 python + appium。而因为我有 JAVA 背景，就选择了 java spring boot 来搭建。一开始实际上就是一个 spring boot application，后面出于兴趣，又改造成了 javafx 做了个可视化页面。\r\n\r\n下面介绍一些基础的配置，不涉及具体的业务测试类：\r\n\r\n1\\. 创建工程：spring 官方出的 spring initializr (https://start.spring.io/(https://start.spring.io/))，简单的填些配置就能自动生成一个 spring 工程，用起来很方便\r\n\r\n2\\. appium 相关的开源包：\r\n\r\njava\r\n<dependency>\r\n  <groupId>io.appium</groupId>\r\n  <artifactId>java-client</artifactId>\r\n  <version>7.0.0</version>\r\n</dependency>\r\n\r\n<!-- https://mvnrepository.com/artifact/org.seleniumhq.selenium/selenium-java -->\r\n\r\n<dependency>\r\n  <groupId>org.seleniumhq.selenium</groupId>\r\n  <artifactId>selenium-java</artifactId>\r\n  <version>3.141.59</version>\r\n</dependency>\r\n\r\n\r\n3\\. 基础配置类和方法：\r\n\r\nJAVA 后台的逻辑启动时，其实就跟在 appium desktop 配置那些参数，点击 start session 是一样的道理。所以需要一个 config 类存储这些参数，再写个方法拉起 session。我的选择是直接利用创建工程自带的 application.properties 来存储 ：\r\n\r\n!(/images/appium/exp3.png)\r\n\r\n然后在是拉起 session 的方法：\r\n\r\n!(/images/appium/exp4.png)\r\n\r\n将这个 void 方法，放到@SpringBootApplication 的主类去执行，就能拉起 APP 了。\r\n\r\n这里值得注意的是这个 URL，这里的地址我并没有放到 application.properties 里去管理。这个地址对应的是最开始，appium 启动服务时对应的地址。我在本地的 4723 端口启动了 appium 服务。所以即使 pom 里使用了 appium 的开源库，有一个服务端起着 appium 服务还是必须的。没有条件在远端库启动服务的话，就像这样配置本地服务就可以了。\r\n\r\n最后一行的 driver，如果以前接触过 selenium 的话应该是熟悉的，在 web 应用，selenium 用的可能是 ChromeDriver 之类的，在安卓就用 AndroidDriver。不熟悉 driver 的，就简单理解他是一个代替你手动点的人，提供一系列定位元素的方法。\r\n\r\n另外还可以初始化一个 wait = new WebDriverWait(driver, timeOutInSeconds) ，wait 对象可以用在页面加载，跳转之类的场景。当你在等待某个元素加载出来再执行某个方法时，用 wait.until 来保证你的代码执行不会快于你的页面元素加载。driver 和 wait 两个对象，就够后面测试类使用了。\r\n\r\n到这里就是基础的配置代码了，后面就是涉及到业务的测试类了：\r\n\r\n这里举个例子，例如我下面这段代码，是拉起 welink-uat 之后，从点击广告页，到登录，最后到主页面的执行方法：\r\n\r\njava\r\nprivate void initWelinkService()\r\n\r\n{\r\n\r\n//Welink UAT首页广告\r\n\r\nwait.until(ExpectedConditions.visibilityOfElementLocated(By.id(\"com.huawei.works.uat:id/iv\\_page\\_img\")));\r\n\r\npauseForLoading(2000);\r\n\r\nmobileActions.tapByCoordinates(379, 1263);\r\n\r\n//进入登录页\r\n\r\nwait.until(ExpectedConditions.visibilityOfElementLocated(By.id(\r\n\r\n\"com.huawei.works.uat:id/et\\_guide\\_login\\_user\\_name\"))).sendKeys(demoConfig.getAccount());\r\n\r\nwait.until(ExpectedConditions.visibilityOfElementLocated(By.id(\"com.huawei.works.uat:id/et\\_guide\\_login\\_password\")))\r\n\r\n.sendKeys(demoConfig.getPassword());\r\n\r\n//登录\r\n\r\nwait.until(ExpectedConditions.visibilityOfElementLocated(By.id(\"com.huawei.works.uat:id/btn\\_login\"))).click();\r\n\r\n//隐私声明页\r\n\r\nwait.until(ExpectedConditions.visibilityOfElementLocated(By.id(\"com.huawei.works.uat:id/agree\"))).click();\r\n\r\n//允许读写日历中的日程信息\r\n\r\nprocessPermissions(driver, \"android:id/button1\", 4000);\r\n\r\n}\r\n\r\n\r\n这里面有几个是我自己包装的工具方法，例如 pauseForLoading，实际上是 Thread.sleep()。还有 processPermissions，APK 底座会弹出请求某个权限的弹框，有时候不止一个，因此我包装了一下，循环点击这些按钮，全部赋权，每个循环停顿一下：\r\n\r\njava\r\npublic static void processPermissions(AndroidDriver<MobileElement> driver, String buttonKey, long pauseMillis)\r\n{\r\n    while (driver.findElements(By.id(buttonKey)).size() > 0)\r\n    {\r\n        driver.findElements(By.id(buttonKey)).get(0).click();\r\n        pauseForLoading(pauseMillis);\r\n    }\r\n}\r\n\r\n\r\n然后是 mobileAction.tapByCoordinates，mobileAction 是一系列手机端操作的工具方法。例如我这里使用到的根据坐标点击，这里是因为我定位不到那个广告首页的确认按钮（有个水印浮在上面），只能根据坐标来点击，这种问题，如果你是相关开发，我建议是有条件就改一下，毕竟用坐标还是没有用 id 之类的好，不同手机不同屏幕大小，坐标难免偏移。但由于这块页面是底座 welink-uat 的实现，只能用坐标了。\r\n\r\n至于坐标值怎么看，appium 的窗口也是能看到的，上边工具栏也有 tap by coordinates 的按钮，点击之后在左侧就能显示出坐标了 ：\r\n\r\n!(/images/appium/appium-coordinates.png)\r\n\r\n类似这样，只要声明一系列的 service 类来执行每一个功能，最后统一注入到 main 方法中执行就行了。\r\n\r\n最后，说一下为什么我没有像原文一样选择 TestNG，而是选择 spring 来执行。实际上 TestNG 确实看起来能符合要求，也是我一开始的方向。将 startupappium 方法放到一个主测试类的@BeforeClass，初始化 driver,wait 对象，后面所有的单元测试类继承这个主测试类，直接就能访问到 driver 和 Wait 去使用。把一系列的测试类用 testSuite 包装，顺序执行，最后还能使用 testNG 自带的测试报告输出。\r\n\r\n例如，这是我原本的 testng.xml ：\r\n\r\n!(/images/appium/testng.png)\r\n\r\n但是！我发现 appium 按照这个顺序执行时，mainTest 执行完，要跳到下一个 test 时，app 会直接闪退。后来也没定位出原因，就换思路使用 spring 了，功能反正也更强大一点。\r\n\r\n1\\. Extent Reports : 一个开源的测试报告工具类，选他的原因单纯就是因为好看，后来发现使用上也挺方便的。这是最终输出的 html 效果图：\r\n\r\n!(/images/appium/extendReports.png)\r\n\r\n2\\. 基于 javafx，写个简单的可视化页面 ：\r\n\r\n配置页面：\r\n\r\n!(/images/appium/javafx1.png)\r\n\r\n执行的进度：\r\n\r\n!(/images/appium/javafx2.png)\r\n\r\n!(/images/appium/javafx3.png)\r\n"},{"slug":"CSSSprites","title":"CSS Sprites 精灵图的概念与在小程序中应用","description":"本次小程序项目中，主包的大小已经大到无法发布了。这时候最先想到的就是把主包里的Static目录的静态图片全部清理掉换成远程图片。但是全部替换的会导致页面加载时会并发很多请求，虽然响应都很快，但是一次请求太多图片资源也是很影响体验的，因此想到了引入精灵图的概念来进行整改。","body":"\r\n在一次小程序项目中，主包的大小已经大到无法发布了。这时候最先想到的就是把主包里的Static目录的静态图片全部清理掉换成远程图片。\r\n\r\n但是全部替换的会导致页面加载时会并发很多请求，虽然响应都很快，但是一次请求太多图片资源也是很影响体验的，因此想到了引入精灵图的概念来进行整改。\r\n\r\n CSS Sprites\r\n---------------------------\r\n\r\n精灵图简单来说就是将多张图片结合到一张图片，让应用通过一次请求拿到之后，通过不同的定位来展示这个图片的不同部分。\r\n\r\n附上一篇讲的很清楚的文章：CSS Sprites: What They Are, Why They’re Cool, and How To Use Them(https://css-tricks.com/css-sprites/)\r\n\r\n这文章里面分享了很多工具，我自己最后选用的是：https://www.toptal.com/developers/css/sprite-generator/(https://www.toptal.com/developers/css/sprite-generator/)\r\n\r\n把图片上传后他会生成精灵图，同时生成需要的css，**而且不会被公司网挡住，他应该是没有上传操作的。**\r\n\r\n 小程序里的应用\r\n---------------------------------------------------------------------------\r\n\r\n在小程序里的应用其实跟在普通H5应用里差不多，看一段实际代码：\r\n\r\ncss\r\n.bg-reliable_png,\r\n.bg-swiperup_svg,\r\n.bg-search_svg,\r\n.bg-icon_cart_less_svg {\r\n    background-image: url('css_sprites.png');\r\n    background-repeat: no-repeat;\r\n    background-size: 498rpx 410rpx;\r\n}\r\n \r\n.bg-icon_cart_less_svg {\r\n    width: 36rpx;\r\n    height: 36rpx;\r\n    background-position: -130rpx -360rpx;\r\n}\r\n\r\n可以看到跟H5不一样的是  \r\n**1\\. 在小程序里因为使用的是rpx，所以用生成器拿到的css样式里都需要把px改成rpx  \r\n2\\. 使用了rpx之后，图片是按px去生成的，所以你需要在手动编辑下图片，看下生成的精灵图大小是什么，通过background-size指定并把px换成rpx，这样图片大小才会也动态的换算**"},{"slug":"Cypress","title":"cypress自动化测试框架使用记录","description":"cypress是纯前端的自动化测试框架，适用于前端web页面；之前搞自动化测试主要是用java的selenium，第一次接触到纯前端的自动化框架，发现他里面的功能还是比较丰富的，语法也很简单。除了可以支持配置在流水线运行之外，他还提供自己的任务看板，录制视频等功能，体验非常好。","body":"cypress 是纯前端的自动化测试框架，适用于前端 web 页面；\r\n\r\n之前搞自动化测试主要是用 java 的 selenium，第一次接触到纯前端的自动化框架，发现他里面的功能还是比较丰富的，语法也很简单。\r\n\r\n除了可以支持配置在流水线运行之外，他还提供自己的任务看板，录制视频等功能，体验非常好。\r\n\r\n 官方文档：\r\n\r\nhttps://www.cypress.io/\r\n\r\n 安装：\r\n\r\ncypress 的安装由于公司网络问题，需要手动配置 binary 路径：\r\n\r\njs\r\nnpm config set CYPRESS_INSTALL_BINARY = \"\"\r\n\r\n\r\n 工程配置：\r\n\r\n安装完成之后，手动执行; cypress 提供两种执行方式，一种是他自带的 CLI 方式启动，一种是后台执行。先看 CLI：\r\n\r\n1\\. cypress cli 启动\r\n\r\njs\r\n./node_modules/.bin/cypress open\r\n\r\n\r\n在你的项目根目录下，他会自动创建 cypress 目录，并且提供一系列的示例脚本：\r\n\r\n!(/images/cypress/cypress1.png)\r\n\r\n执行上面命令失败一般由于是网络问题，需要定义环境变量 HTTP_PROXY，可以确认你的系统是否有这个环境变量。\r\n\r\n我是在执行前再手动设置才成功的：\r\n\r\n$env:HTTP_PROXY = \"http://yourproxy.com\"\r\n\r\n执行后会自动跳出 CLI 窗口：\r\n\r\n!(/images/cypress/cypress2.png)\r\n\r\n在这个页面最基本的，可以手动双击里面的 spec 文件，体验一下他的 cypress 运行；\r\n\r\ncypress 最大的一个亮点，我个人认为在他的 Runs 页签中：\r\n\r\nRuns 页签对应他的 dashboard 功能，这里面在你设置了自己的项目后（查看他的官网 dashboard 介绍(http://https://www.cypress.io/dashboard)），会记录每次你执行的任务：\r\n\r\n!(/images/cypress/cypress3.png)\r\n\r\n这里是在 cli 下的界面，你也可以点右上角的“See all runs”，进到他的 web 页面：\r\n\r\n!(/images/cypress/cypress4.png)\r\n\r\n这里面提供各种分析面板，帮助记录任务，分析结果等等。页面的体验也做得非常好。\r\n\r\n2\\. 后台执行\r\n\r\n上面说得 cypress cli 只是用来让用户体验执行方式的，真的要投入项目使用，能放在 CI 流水线上执行是最方便的，cypress 也支持此种运行方式。\r\n\r\n最重要的，后台运行的方式是支持并行执行测试的，cli 下是不行的。（但是如果是你的 PC 本地后台运行，cypress 为了避免把你卡死，是限制并行的，想测试并行，最好还是放到例如 jenkins 任务中去运行）\r\n\r\n而且你可以指定录制运行，把每个 spec 的执行都录制下来，方便你去查看问题出现的地方。\r\n\r\n运行命令：官方命令文档(https://docs.cypress.io/guides/guides/command-line.htmlcypress-run)\r\n\r\n全量运行：npm run cypress run (或者在 package.json 下定义命令 例如 cy: run : \"cypress run \" => npm run cy:run)\r\n\r\n指定运行某测试并录制：\r\n\r\n1\\. 需要 record-key，在你的 dashboard 下可以查看（记得注册项目）\r\n\r\n2\\. 网络限制的话，记得执行代理设置\r\n\r\n- $env:CYPRESS_RECORD_KEY = \"your record key\"\r\n\r\n- $env:HTTP_PROXY = \"http://localhost:3128\"\r\n\r\n- npm run cy:run -- --record --spec \"cypress/and the path to your spec.ts/spec.ts\"\r\n\r\n执行之后，可以去你的 dashboard 看到执行任务。\r\n"},{"slug":"GraphQL","title":"GraphQL 基础实践 nodejs & Java","description":"GraphQL 是由facebook提出的，一种协助前后台之间交流的语言。比起传统的REST api，他主要解决 overfetching 和 underfetching 两种问题。","body":"GraphQL 是由 facebook 提出的，一种协助前后台之间交流的语言。比起传统的 REST api，他主要解决 overfetching 和 underfetching 两种问题。\r\n\r\noverfetching 简单来说指的是我调用一次接口，返回了 10 个字段给我，而我可能只需要其中 5 个字段。\r\n\r\n这种情况是我个人最常经历的，当你的应用对接的后台是个很公共的服务，他又对接太多租户时，他可能在一个接口上把所有字段都吐给你，而其中 3 个字段是租户 A 才要的，3 个字段是租户 B 要的，最后才是你要的。导致报文又长又浪费，尤其是在做小程序时，一切都要精简轻量最好。\r\n\r\nunderfetching 则是指的我需要的信息，可能需要调用接口 A，拿到某个 ID，再调用接口 B，最后才能整合成我需要的信息。说白了就是需要多次请求调用。\r\n\r\n想要推动这些后台去优化他们的 API 难比登天，那么假如我能在中间搭建一个服务，请求接口后包装成 GraphQL api，前端统一都用 graphql 请求的话，是否会让一切方便许多？\r\n\r\n下面将会展示如何在 nodeJs 下搭建一个 GraphQL Server：\r\n\r\n首先是我的目录结构：\r\n\r\n!(/images/graphql/graphql1.png)\r\n\r\n1\\. Apollo Server(https://www.apollographql.com/docs/apollo-server/) :\r\n\r\n我选择的服务端框架是 ApolloGraphQL，他提供完整的 Server 和 Client 两个端的框架，用起来体验还是很不错的。\r\n\r\n2\\. 关于目录结构，我是参考链接：https://github.com/betaflag/graphql-server-scaffolding(https://github.com/betaflag/graphql-server-scaffolding)\r\n\r\n里面有三种关于不同目录结构的分析，我个人认为这种目录结构已经把 GraphQL 的概念分的很清楚了\r\n\r\n3\\. Data, resolver, typeDefs:\r\n\r\n以上基本概念可以看官网，或者看这个视频也讲的很清楚 =》https://www.youtube.com/watch?v=lKlXdmG0aKQ(https://www.youtube.com/watch?v=lKlXdmG0aKQ)\r\n\r\n后面展开讲实际开发：\r\n\r\n1\\. 类型的定义：例如这是一个实际的 REST API 接口报文：\r\n\r\n我们首先需要在 typeDefs 下写以上接口报文里的那些类型定义：\r\n\r\n\\*typeDefs/types/agreement.js\r\n\r\njs\r\nconst { gql } = require(\"apollo-server\");\r\n\r\nconst agreement = gql\r\n  type AgreementResult {\r\n    scenarioType: String\r\n\r\n    versionType: String\r\n\r\n    tenantId: String\r\n\r\n    tenantName: String\r\n\r\n    versionDescription: String\r\n\r\n    lastVersion: String\r\n\r\n    agreementBody: String\r\n\r\n    personalizedSigning: String\r\n\r\n    displayStatus: String\r\n\r\n    status: String\r\n\r\n    agreementName: String\r\n  }\r\n\r\n  type Agreement {\r\n    status: String\r\n\r\n    code: String\r\n\r\n    message: String\r\n\r\n    result: AgreementResult\r\n  }\r\n;\r\n\r\nmodule.exports = {\r\n  agreement\r\n};\r\n\r\n\r\n这里用到的定义语法叫SDL(schema definition language)(https://www.apollographql.com/docs/apollo-server/schema/schema/)\r\n\r\n2\\. dataSource\r\n\r\n再来就是数据的来源了；网上的视频，包括我在上面附的那个链接，大部分都是静态资源的 datasource。而在实际应用中，例如我自己的场景，我需要的数据是从 rest api 获取的，而 apollo 也有提供对应的库 - 'apollo-datasource-rest'；\r\n\r\n（实际上，apollo 还提供很多种数据源依赖库，可以看这个链接：https://www.apollographql.com/docs/apollo-server/data/data-sources/(https://www.apollographql.com/docs/apollo-server/data/data-sources/)）\r\n\r\n\\*data/agreement.js\r\n\r\njs\r\nconst { RESTDataSource } = require(\"apollo-datasource-rest\");\r\n\r\nclass ScrmApi extends RESTDataSource {\r\n  constructor() {\r\n    super();\r\n\r\n    this.baseURL = \"https://weblink01-ts.huawei.com/\";\r\n  }\r\n\r\n  async getAgreement() {\r\n    return this.get(\r\n      \"/uat/scrm_customer/cui/agreement/newest/v2?appSource=HLife\"\r\n    );\r\n  }\r\n}\r\n\r\nmodule.exports = { ScrmApi };\r\n\r\n\r\n一个简单的 GET 请求。\r\n\r\n使用这个 dataSource，需要去入口文件的 ApolloServer 中注册：\r\n\r\njs\r\nconst { ApolloServer } = require(\"apollo-server\");\r\n\r\nconst { RandomUser, ScrmApi } = require(\"./data\");\r\n\r\nconst { typeDefs } = require(\"./typeDefs\");\r\n\r\nconst { resolvers } = require(\"./resolvers\");\r\n\r\n//nodejs version under 11 might need this import\r\n\r\nrequire(\"core-js/stable\");\r\n\r\nconst server = new ApolloServer({\r\n  typeDefs,\r\n\r\n  resolvers,\r\n\r\n  dataSources: () => ({\r\n    RandomUser: new RandomUser(),\r\n\r\n    scrmApi: new ScrmApi()\r\n  })\r\n});\r\n\r\nserver.listen().then(({ url }) => {\r\n  console.log(🚀 Server ready at ${url});\r\n});\r\n\r\n\r\n3\\. resolver：最后只需要在 resolver 中添加就行了\r\n\r\n\\*resolvers/index.js\r\n\r\njs\r\nconst resolvers = {\r\n  Query: {\r\n    getUser: async (_, { gender }, { dataSources }) =>\r\n      dataSources.RandomUser.getUser(gender),\r\n\r\n    getUsers: async (_, { people, gender }, { dataSources }) =>\r\n      dataSources.RandomUser.getUsers(people, gender),\r\n\r\n    agreements: async (_, __, { dataSources }) => {\r\n      return dataSources.scrmApi.getAgreement();\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = {\r\n  resolvers\r\n};\r\n\r\n\r\n总新增一个 graphQL 查询就完成了，可以用 npm run start 直接运行，会出现一个 graphql-playground 的页面供你测试你的 API：\r\n\r\n（此页面是基于 apollo-server 自带的一个 sandbox 项目运行的，可能会被公司网屏蔽导致页面加载不出来，可以用 cntlm 转发或者开透明代理）\r\n\r\n最终页面：\r\n\r\n!(/images/graphql/graphql2.png)\r\n\r\n可以看到现在我们可以根据自己需要，跟后台获取自己要的字段，过滤掉不需要的字段了。而且在写 query 时还会自动提示你的接口字段。\r\n\r\n到此，一个基于 nodeJs 的基本 GraphQL server 就搭建起来了。部署的话，官方有提供很多解决方案，例如 express，不过申请资源太麻烦了，我个人没有试过。感兴趣的可以试一下。\r\n\r\n考虑到部署，我个人还是觉得 java 会更成熟一点，因此也基于 java 的搭建了一版：\r\n\r\nGraphQL 支持很多语言也是他很好的一个优点。\r\n\r\nJava 版：https://www.graphql-java.com/tutorials/getting-started-with-spring-boot/(https://www.graphql-java.com/tutorials/getting-started-with-spring-boot/)\r\n\r\n我基本上是照着原指导操作的，因此这里就不再赘述了，感兴趣的可以自己试一下。\r\n\r\n不过基于这种方式搭建的服务，需要另外有个测试 API 的页面，也就是文档里最后说的 GraphQL Playground(http://https://github.com/graphql/graphql-playground)。github 链接里有很多版本，我最后是用最简单的 html 直接运行的。不过需要解决下 CORS 请求问题就是了，详细的可以看我的 github 源码 - java 版 GraphQL Server(https://github.com/l00437994/graphql-java-project)。\r\n\r\n以上都是关于搭建 Server，那么关于 Client 侧的使用：这里我只举 Vue 项目和微信小程序\r\n\r\n1. Vue Apollo(https://apollo.vuejs.org/guide/)\r\n\r\n使用：\r\n\r\n!(/images/graphQL/graphql3.png)\r\n\r\n这里要注意的是，一定要用 object 把 apollo 下的对象包起来：\r\n\r\njs\r\napollo: {\r\n\r\n    //this won't work\r\n\r\n    agreements: gql\r\n\r\n    query {\r\n\r\n          agreements {\r\n\r\n            agreementBody\r\n\r\n            agreementName\r\n\r\n          }\r\n\r\n        }\r\n\r\n    ,\r\n\r\n    //wrap it in object\r\n\r\n    agreements: {\r\n\r\n      query: gql\r\n\r\n        query {\r\n\r\n          agreements {\r\n\r\n            agreementBody\r\n\r\n            agreementName\r\n\r\n          }\r\n\r\n        }\r\n\r\n      \r\n\r\n    }\r\n\r\n  }\r\n\r\n\r\n2. 微信小程序：\r\n\r\n由于我的出发点实际上是想应用在微信小程序，发现直接在微信小程序上用 vue-apollo 是会报错的。\r\n\r\n不过微信有一套自己维护的 graphql 框架：‘wxapp-graphql’\r\n\r\n使用：\r\n\r\njs\r\nlet gql = require('wxapp-graphql');\r\n\r\nconst GraphQL = gql.GraphQL;\r\n\r\n\r\n\r\ngql = GraphQL({\r\n\r\n    url: 'http://localhost:8080/graphql'\r\n\r\n}, true);\r\n\r\n\r\n\r\nexport default gql;\r\n\r\n\r\n在你需要的地方 import gql from './上面这段代码.js'\r\n\r\n通过 query 之后的回调来访问最后的结果：\r\n\r\njs\r\ngql.query({\r\n\r\n                query: query {\r\n\r\n                            agreements {\r\n\r\n                                agreementBody\r\n\r\n                                agreementName\r\n\r\n                                status\r\n\r\n                                }\r\n\r\n                        }\r\n\r\n            }).then(res => {\r\n\r\n                console.log('query result: ', res);\r\n\r\n            });\r\n\r\n\r\n最后是几个有用的资料：\r\n\r\n1\\. vscode 开发插件： GraphQL; Idea 开发插件：js-graphql\r\n\r\n2\\. typerscript-boilderplate: https://github.com/graphql-boilerplates/typescript-graphql-server\r\n\r\n3\\. wxapp-graphql: https://github.com/Authing/wxapp-graphql\r\n"},{"slug":"JestSpyOn","title":"【Jest】mock/spyOn同一个module下的调用方法不生效的问题：作用域","description":"记一次在使用jest mock方法不起作用的问题和解决方案。","body":"记一次在使用jest mock方法不起作用的问题和解决方案：\r\n\r\n  \r\n\r\n场景：假设待测试方法a 来自 module A，而方法a其又调用了方法b，此方法b也属于module A。为了专注于方法a的测试，要mock 方法b\r\n\r\n  \r\n\r\n例如：module A的代码如下\r\n\r\njs\r\nexport function a: ()  {\r\n   // a calls b\r\n   if (b()) {\r\n     return true;\r\n   } else {\r\n     return false;\r\n   }\r\n}\r\n\r\nexport function b: () {\r\n   // whatever\r\n}\r\n\r\n  \r\n\r\n在测试代码中我们尝试mock b函数的返回值为true，并expect a返回true\r\n\r\njs\r\n// example.test.ts\r\nimport * as A from '../A'\r\n\r\njest.mock('../A', () => {\r\n  const originalModule = jest.requireActual('../A');\r\n\r\n  //Mock the default export and named export 'foo'\r\n  return {\r\n    __esModule: true,\r\n    ...originalModule,\r\n    b: jest.fn()\r\n  };\r\n})\r\n\r\ndescribe('a test that shows mock won't work in this case', () => {\r\n     test('mock b function and expect a function to return as expect', () => {\r\n          // IMPORTANT: this wont work!!!\r\n          b.mockReturnValueOnce(true);\r\n          expect(a()).toBe(true)\r\n    })\r\n})\r\n\r\n\r\n  \r\n\r\n但实际测试会发现，这里b的mock并不生效。实际在执行a()时，还是走到了b的实际方法去了而不是我们mock的返回。\r\n\r\n即使换成jest.spyOn的写法也是一样的。\r\n\r\n  \r\n\r\n根因：由于方法a和方法b都属于moduleA，然后方法a是直接引用的方法b，所以方法b的引用就会固定在方法a的作用域中，不管是mock还是spyOn都会不起作用。\r\n\r\n  \r\n\r\n首先想到的解决方案：\r\n\r\n例如重构代码，将两个方法a和方法b分开到不同文件，但我的本意是写单元测试，因而去改源码让我无法接受。\r\n\r\n  \r\n\r\n搜了很多网上的例子，有推荐使用开源依赖，sinon(https://sinonjs.org/) 来创建mock的方案，但最后试过了还是不行。\r\n\r\n  \r\n\r\n最后解决方案：参考 https://github.com/sinonjs/sinon/issues/1684(https://github.com/sinonjs/sinon/issues/1684)\r\n\r\n  \r\n\r\n!(/images/JestSpyOn/1.png)\r\n\r\n  \r\n\r\n实际上就是避免函数声明，可以避免函数被封装在模块函数里，用const 来定义函数的话，这个方法只会成为这个模块对象的属性。\r\n\r\n  \r\n\r\n最后我的修改：先修改方法b的声明方式：\r\n\r\n  \r\njs\r\nexport function a: ()  {\r\n   // a calls b\r\n   if (b()) {\r\n     return true;\r\n   } else {\r\n     return false;\r\n   }\r\n}\r\n\r\n// before: export function b() { ... }\r\nexport const b =  () =>  {\r\n   // whatever\r\n}\r\n\r\n  \r\n\r\n然后修改测试方法，用sinon.stub模拟方法返回。\r\n\r\njs\r\n// example.test.ts\r\nimport * as A from '../A'\r\n\r\n// add sinon\r\nimport sinon from 'sinon';\r\n\r\njest.mock('../A', () => {\r\n  const originalModule \\= jest.requireActual('../A');\r\n\r\n  //Mock the default export and named export 'foo'\r\n  return {\r\n    \\_\\_esModule: true,\r\n    ...originalModule,\r\n    b: jest.fn()\r\n  };\r\n})\r\n\r\ndescribe('a test that shows mock won't work in this case', () => {\r\n     test('mock b function and expect a function to return as expect', () \\=> {\r\n          // works like charm\r\n          const bStub \\= sinon.stub(A, 'b');\r\n          bStub.returns(true);\r\n          expect(a()).toBe(true)\r\n    })\r\n})\r\n\r\n  \r\n\r\n总结来说：\r\n\r\n产生这个问题还是由于方法作用域没有搞清楚的原因导致的，但如果只是修改方法的声明，继续使用jest.mock经尝试还是不行，因此最后还是使用了sinon。"},{"slug":"Playwright","title":"基于playwright的E2E自动化测试框架搭建","description":"Playwright是2023年度github上获星数最多的自动化框架，可以完成多浏览器的自动化测试，具有录制，截屏，自动重试等功能，也有优化开发体验的vscode插件。鉴于项目上正好要使用相关能力，以下记录我在使用过程中遇到的一些问题和解决方法。","body":"Playwright(https://playwright.dev/)是2023年度github上获星数最多的自动化框架，可以完成多浏览器的自动化测试，具有录制，截屏，自动重试等功能，也有优化开发体验的vscode插件。鉴于项目上正好要使用相关能力，以下记录我在使用过程中遇到的一些问题和解决方法：\r\n  \r\n\r\n内网下载：\r\n\r\n  \r\n\r\n按照官网的描述：\r\n\r\nnpm init playwright@latest\r\n\r\n如果你是在内网环境，一定会遇到报错。\r\n\r\n!(/images/playwright/playwright1.png)\r\n\r\n在下载的过程中，除了安装@playwright，还会去下载各浏览器，默认是会下载chromium，webkit，firefox三个。\r\n\r\n而就是这三个的下载会因为内网限制超时。\r\n\r\n解决方案：自行到cdn下载浏览器，然后手动解压\r\n\r\n到**C:\\\\Users\\{用户名}\\AppData\\Local\\ms-playwright**目录下，手动把附件的下载包解压：\r\n\r\n新建如下目录：/chromium-1097、/firefox-1438、/webkit-1967\r\n\r\n（注意我这里写的每个浏览器的版本是与附件相符合的，不清楚这里对于版本有没有要求，按报错时的提示目录来新建目录即可）\r\n\r\n!(/images/playwright/playwright2.png)\r\n\r\n  \r\n\r\n将安装包解压到对应目录即可。\r\n\r\n  \r\n\r\nchromium：\r\n\r\n!(/images/playwright/playwright3.png)\r\n\r\n  \r\n\r\nfirefox：\r\n\r\n!(/images/playwright/playwright4.png)\r\n\r\n  \r\n\r\nwebkit: \r\n\r\n!(/images/playwright/playwright5.png)\r\n\r\n  \r\n\r\n  \r\n\r\n目录结构：\r\n\r\n  \r\n\r\n若你是执行的以上命令直接init的话，会是以下的目录结构：（例如我在e2e目录下执行的init命令）\r\n\r\n!(/images/playwright/playwright6.png)（忽略contant是我自定义的目录）\r\n\r\n其中需要注意的是\r\n\r\n*   /tests 目录用来存放所有测试的spec文件，当然这个目录也是可以自定义的，在init命令时可配置\r\n*   /tests-examples是他自带的demo\r\n*   /test-results用来存放你的测试结果，如果有失败的话，会把对应的trace文件存放在此目录下；开启了录制功能的话，视频也会存储在此\r\n*   /playwright-report同样存放测试的结果，与test-results不一样的是，他存放的是一个html，直接让你看到你的测试结果\r\n*   /playwright.config.ts 是playwright的配置文件，详细可以参考：https://playwright.dev/docs/test-configuration(https://playwright.dev/docs/test-configuration)  \r\n    \r\n\r\n  \r\n\r\nplaywright.config.ts全局配置文件\r\n\r\n  \r\n\r\n全局配置的每个配置项信息可以在官网查看，这里我个人用到的是以下几个：\r\n\r\njs\r\nuse: {\r\n        /* Base URL to use in actions like await page.goto('/'). */\r\n        // baseURL: 'http://127.0.0.1:3000',\r\n        launchOptions: {\r\n            proxy: { server: 'per-context' },\r\n            args: '--ignore-https-errors', '--disable-web-security'\r\n        },\r\n        // 浏览器全局代理\r\n        proxy: {\r\n            server: 'http://127.0.0.1:8888',\r\n            username: 'ProxyUserName',\r\n            password: 'password'\r\n        },\r\n        // 忽略HTTPS的相关错误\r\n        ignoreHTTPSErrors: true,\r\n        // 忽略CORS\r\n        bypassCSP: true,\r\n        /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */\r\n        trace: 'on-first-retry',\r\n        video: 'on-first-retry'\r\n    },\r\n\r\n/* Configure projects for major browsers */\r\n    projects: \r\n        {\r\n            name: 'chromium',\r\n            use: { ...devices'Desktop Chrome' }\r\n        },\r\n        {\r\n            name: 'firefox',\r\n            use: { ...devices'Desktop Firefox' }\r\n        },\r\n        {\r\n            name: 'webkit',\r\n            use: { ...devices'Desktop Safari' }\r\n        },\r\n        /* Test against mobile viewports. */\r\n        // 模拟在微信上的使用场景 微信小程序里使用的内核其实还是webkit\r\n        {\r\n            name: 'Mobile IOS',\r\n            use: { ...devices'iPhone 12', isMobile: true }\r\n        },\r\n        // APP的场景\r\n        {\r\n            name: 'Huawei Mate 30 Pro',\r\n            use: {\r\n                defaultBrowserType: 'webkit',\r\n                viewport: { width: 392, height: 800 },\r\n                isMobile: true\r\n            }\r\n        },\r\n        {\r\n            name: 'Huawei MatePad Pro',\r\n            use: {\r\n                defaultBrowserType: 'webkit',\r\n                viewport: { width: 1280, height: 800 },\r\n                isMobile: false\r\n            }\r\n        }\r\n\r\n        /* Test against branded browsers. */\r\n        // {\r\n        //   name: 'Microsoft Edge',\r\n        //   use: { ...devices'Desktop Edge', channel: 'msedge' },\r\n        // },\r\n        // {\r\n        //   name: 'Google Chrome',\r\n        //   use: { ...devices'Desktop Chrome', channel: 'chrome' },\r\n        // },\r\n    \r\n\r\n  \r\n\r\n\r\n\r\n这里projects配置项就是一个比较方便的能力，由于我的项目需要在多个浏览器下执行测试，在这里可以定义不同的测试project，而且有自带的devices让你选择。\r\n\r\n像我这里需要模拟微信和其他APP的场景，由于内核都是用的webkit，因此指定浏览器的defaultBrowserType和viewport就能达到模拟的效果。"},{"slug":"StudentVerify","title":"微信小程序 学生认证插件接入指南","description":"因业务需求，预研了微信官方新提供的“学生身份快速验证”插件，下面说明下如何申请及实际接入插件。","body":"因业务需求，预研了微信官方新提供的“学生身份快速验证”插件，官方文档如下：\r\n\r\n  \r\n\r\nhttps://developers.weixin.qq.com/miniprogram/dev/platform-capabilities/industry/student.html(https://developers.weixin.qq.com/miniprogram/dev/platform-capabilities/industry/student.html)\r\n\r\n  \r\n\r\n下面说明下如何申请及实际接入插件：\r\n\r\n  \r\n\r\n插件权限申请：\r\n\r\n  \r\n\r\n接入学生身份快速验证插件，首先要按文档上说的，在小程序后台点击开通：\r\n\r\n!(/images/studentVerify/1.png)\r\n\r\n  \r\n\r\n点击开通后会需要输入小程序的类目和相关业务场景的用途信息，最好在附上一点交互图，方便微信审核：\r\n\r\n!(/images/studentVerify/2.png)\r\n\r\n这一步按官方文档来，申请上没遇到什么坑，基本没什么问题\r\n\r\n  \r\n\r\n申请通过之后，在小程序的后台，就会看到这样的界面，可以在这里添加测试账号就说明审核通过了\r\n\r\n!(/images/studentVerify/3.png)\r\n\r\n  \r\n\r\n但是这里有一步，文档没有提到，要真的使用，还需要去设置里添加插件才行：\r\n\r\n  \r\n\r\n在小程序后台找到 设置 -> 第三方设置 -> 插件管理\r\n\r\n!(/images/studentVerify/4.png)\r\n\r\n  \r\n\r\n在这一步要点击添加插件，然后将学生身份验证插件添加进去，因为前面学生验证他已经审核过了，所以他会自动通过。这样调试时才不会报错。这一点文档上没有说，属于实际接入时发现的坑。\r\n\r\n  \r\n\r\n功能介绍：\r\n\r\n  \r\n\r\n按照文档，此插件有区分所谓的“快速验证”和“补充学籍验证”两种验证方式\r\n\r\n对于第一次验证的用户，一定会要经过“补充学籍验证”，即下图这种方式：\r\n\r\n!(/images/studentVerify/5.png)\r\n\r\n  \r\n\r\n若上图的人脸验证不通过，重新验证的交互如下图，会走到学信网的那条路去做验证：\r\n\r\n  \r\n\r\n!(/images/studentVerify/6.jpg)\r\n!(/images/studentVerify/7.jpg)\r\n!(/images/studentVerify/11.jpg)\r\n\r\n  \r\n\r\n实现流程：\r\n\r\n  \r\n\r\n微信官方提供了一个插件和一个查询接口，分别是：\r\n\r\n前端用的授权插件弹窗：studentVerify\r\n\r\n!(/images/studentVerify/8.png)\r\n\r\n后端查询学生验证状态的接口：!(/images/studentVerify/9.png)\r\n\r\n  \r\n\r\n插件的接入没有什么疑问，按照文档来即可。下图是后台整体验证的交互流程：\r\n\r\n  \r\n\r\n!(/images/studentVerify/10.png)\r\n\r\n  \r\n\r\n此接口使用需要几个条件：\r\n\r\n1.  用户的openid：此用户在此小程序下的openid，一般接入了微信登录的后台肯定能获取到此openid\r\n2.  access\\_token：注意这里经过实际接入发现其实要的是stableAccessToken(https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/getStableAccessToken.html)，而不是他官方文档说的accessToken。\r\n\r\n> stableAccessToken获取的方式还是小程序的appid和appsecret，不过他比accessToken来说，他有自动缓存的机制，不像accesstoken每次请求就重新刷新，他给了一个控制入参来控制是否要刷新!(/images/studentVerify/11.png)  \r\n    \r\n3.  wx\\_studentcheck\\_code：这是需要用户授权才能获取的，也就是前端使用插件，用户点击允许后才能获取到的授权code\r\n\r\n  \r\n\r\n常见问题：\r\n\r\n1.  查询实时性问题：绑定完成之后的状态可以用一个服务端来存，但是比如若用户毕业了，状态是不会自动刷新的。每次要查询都需要用户授权才可以重新查到最新的学籍状态\r\n2.  与微信号绑定：学生认证的结果是跟微信号绑定的，假如A微信号绑定了学生A，此时又用B微信号想去验证学生A，此时会自动与微信号A解绑并与B微信号绑定，但是1年内无法再次绑定任意微信号\r\n3.  测试账号：在后台添加测试账号的用户，在做学生认证时即使你并不是真的学生，也会认证通过。相反没有添加测试账号的用户，那就会真的校验你是否学生了。测试账号只能添加5个，而且添加需要该账号微信扫码。删除时需要管理员扫码才能删除。"},{"slug":"UniappSubpackage","title":"uniapp 小程序包大小优化 - 主包与分包","description":"这次项目中遇到要新引入依赖，但是发现依赖进来之后包已经大的无法发布了。因此做了一次代码包的整改清理，有一些坑是我之前没想到的，在这里记录一下。","body":"这次项目中遇到要新引入依赖，但是发现依赖进来之后包已经大的无法发布了。因此做了一次代码包的整改清理，有一些坑是我之前没想到的，在这里记录一下。\r\n\r\n  \r\n\r\n关于小程序的主包与分包：\r\n\r\n  \r\n\r\n目前主流小程序都支持分包的概念，uniapp目前也是支持的。\r\n\r\n  \r\n\r\n例如微信小程序，发布小程序时限制主包的大小不能超过2M，如果你什么都往主包放，那么迟早有一天会撑到上限，因此需要分包的概念。\r\n\r\n  \r\n\r\n 分包的配置方法：\r\n\r\nhttps://uniapp.dcloud.io/collocation/pages?id=subpackages(https://uniapp.dcloud.io/collocation/pages?id=subpackages)  \r\n\r\n  \r\n\r\n实际上配置很简单，我认为有几点需要强调的是：\r\n\r\n  \r\n\r\na. 如果你要把一个组件或js方法（vue最后也是打成JS，后面都按JS去一起说）放到某个分包里，这个JS必须不能被主包的任何JS直接或间接引入，否则一定会被打到主包里。\r\n\r\n  \r\n\r\nb. 主包的页面，JS，不可以直接或间接的引入分包的JS！但是反过来，分包可以引主包的JS。\r\n\r\n  \r\n\r\nc.  uniapp目前不支持分包加载其他分包的组件，但是微信小程序是支持的（分包异步加载，可以看这里(https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/async.html)）\r\n\r\n  \r\n\r\nd. 分包可以引分包的JS，后果是这个JS会被打到主包里。分包不可以引分包的组件！预加载也不可以！除非用上面异步加载的方法！\r\n\r\n  \r\n\r\nuniapp官方推荐的分包方法：\r\n\r\n  \r\n\r\n\\=》主包里只放默认启动页面/tabbar相关的页面，从tabbar页面开始跳转到的其他业务页面，全部放到分包里。 \r\n\r\n  \r\n\r\n但是由于上面分包的限制，默认启动页/tabbar相关页面里所有用到的组件，公共方法，静态图片，都必须在主包里。\r\n\r\n  \r\n\r\n综上，你可以看到你的主包里，不可避免的至少会有你的默认启动页，和看你的tabBar有多少个子项了。\r\n\r\n  \r\n\r\n  \r\n\r\n最后有一点比较有趣的是关于npm依赖：\r\n\r\n  \r\n\r\nQ: npm依赖是否支持分包？如果我有个npm依赖只在某个分包里引用了，他可以只被打到分包里吗？\r\n\r\n  \r\n\r\n从我这次的经验来看，uniapp是一定会把npm依赖打到主包的vendor里的。不管他这个依赖是不是只在分包里引用了。而且例如像微信小程序，他不止会打到vendor里占位置，最后在主包的node-modules目录下也会有一定大小占着，举个例子：\r\n\r\n  \r\n\r\n!(/images/uniapp/uniapp1.png)\r\n\r\n  \r\n\r\n虽然node-modules下已经有这些依赖的代码了，但是假如仔细去看vendor的话，你会发现vendor下也会有这些依赖的代码。\r\n\r\n  \r\n\r\n这其实就很尴尬了，在vendor里占位置就算了，node-modules里又有一份，让我觉得很多余，而且又必须在主包里。但uniapp官方目前没有提供解决方法。\r\n\r\n  \r\n\r\n  \r\n\r\n  \r\n\r\n我后来找到一个方法，通过babel来修改依赖的路径，核心思想就是把这些依赖复制到分包里，用相对路径引用，然后再打包 =》\r\n\r\n  \r\n\r\nuni-app如何支持npm分包：https://ask.dcloud.net.cn/article/37757(https://ask.dcloud.net.cn/article/37757)\r\n\r\n  \r\n\r\n这方法亲测有效，唯一的坏处就是他会把依赖的代码复制到你的源码里，因此你需要再他打完包后，在写段脚本把他们清掉。"},{"slug":"VRinMiniprogram","title":"小程序中的VR全景组件研讨","description":"现在越来越多项目选择用小程序来展示VR业务，而腾讯，阿里等也陆续推出他们的VR解决方案，本篇主要记录在微信小程序 & 淘宝小程序上实现VR的几种途径。","body":"> 现在越来越多项目选择用小程序来展示 VR 业务，而腾讯，阿里等也陆续推出他们的 VR 解决方案，本篇主要记录在微信小程序 & 淘宝小程序上实现 VR 的几种途径。\r\n\r\n 微信小程序：\r\n\r\n1. Threejs for miniprogram(https://developers.weixin.qq.com/miniprogram/dev/extended/utils/threejs.html)\r\n\r\nthreejs 作为 H5 端通用的渲染 webgl 的代码库，微信也推出了他在此基础上的小程序适配版。只要在 template 中使用 webgl 的 canvas，在 js 中选择节点注册到 Threejs 中，之后的使用就跟正常的 H5 使用没有什么区别了：\r\n\r\ngit 地址： https://github.com/wechat-miniprogram/threejs-miniprogram 其中 example 目录为可直接运行的 demo 小程序。\r\n\r\nwxml :\r\n\r\n!(/images/vr/vr1.png)\r\n\r\nindex.js :\r\n\r\n!(/images/vr/vr2.png)\r\n\r\n贴一个实用类的 VR 实现帖：https://www.cnblogs.com/xuejiangjun/p/11815650.html\r\n\r\n问题：\r\n\r\n如果你按照以上实现去实施全景图，你会发现他能在开发者工具上正常展示，但是一旦到了真机，就会出现黑屏的现象。\r\n\r\n打开调试器，你会看到以下警告：\r\n\r\n这个问题在 threejs-miniprogram 的 git 库上作为一个 open issue 存在: https://github.com/wechat-miniprogram/threejs-miniprogram/issues/35\r\n\r\nissue 中提到是 IOS 端复现此问题，但经过我的验证此问题在安卓端也会出现。\r\n\r\n结论：threejs 虽然是腾讯官方推的 3D 渲染库，也的确支持了其他 threejs 的 webgl 渲染功能，但是他在渲染 texture 纹理上还有问题，因此渲染全景图的 VR 业务场景暂时还不能满足。\r\n\r\n2\\. webview(https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html) ：\r\n\r\n既然小程序上无法满足，那么我们的思路自然转到 H5 上使用 threejs，在使用 webview 进行跳转。经过调研，业界很多微信小程序供应商，提供 VR 小程序的定制功能的，也普遍都是此解决方案。\r\n\r\nH5 上使用 threejs 是没有问题的，这个不在这里多加描述了，这里提一下 webview 的一些局限：\r\n\r\n1\\. 只有企业版微信才开放 webview 组件能力，个人小程序不开放。\r\n\r\n2\\. 小程序与 webview 通信：\r\n\r\nuniapp， 微信官方都有提供小程序与 webview 通信的 API： postMessage；\r\n\r\nweb 页面中调用 postMessage，小程序并不会直接响应，而是在以下场景才会响应事件获取到信息：1\\. 分享 2. 组件摧毁 3. 页面回退\r\n\r\n这里是一篇比较详细的例子：https://segmentfault.com/a/1190000020122429\r\n\r\n3\\. 限定的 SDK API：web 页面中能使用的 sdk 非常有限，支持的接口在官方文档中查看，需要看自己的业务场景能否满足。\r\n\r\n4\\. webview 缓存问题：这是一个在微信小程序社区上讨论很久的问题了，但是微信官方一直没有解决。webview 组件的缓存非常严重，怎么清都清不掉。链接：https://developers.weixin.qq.com/community/develop/doc/000ee40c700ec0cb4b079a13856000\r\n\r\n淘宝小程序：\r\n\r\n​​ 淘宝小程序不像微信，他并不支持 threejs，官方也没有推出适配版本。并且淘宝限制了 webview 组件的域名，只允许手淘官方页域名。因此微信小程序中的两个解决方案在淘宝小程序中都不可行。淘宝官方给出的解决方案为LayaAir(https://miniapp.open.taobao.com/docV3.htm?docId=119179&docType=1&tag=dev)。\r\n\r\nLayaAir 本身是个游戏制作引擎，他也有 3D 的 webgl 渲染库，与淘宝合作后有自己的一套解决方案。\r\n\r\n照着文档来操作，是可以顺利导出一个可使用的 VR 小程序，并且可以在里面使用所有淘宝小程序的 API。\r\n\r\n 注意点：\r\n\r\n1\\. enableSkia：文档中提到的此配置项，打开后会导致原生 canvas 对象全部改为 skia 库的对象。若原项目中使用了 my.createCanvasContext 接口来操作 canvas 组件，你会发现之前的代码全部失效了。因为原生对象已经完全变样了。\r\n\r\n对此我使用过他文档中另外推的一个PIXIJS(https://miniapp.open.taobao.com/docV3.htm?docId=119002&docType=1&tag=dev)的绘图库，也是淘宝在 pixijs 上做的适配版本。\r\n\r\npixijs 个人感觉没有原 canvas 那么简单好用，而且遇到过很多兼容性问题。\r\n\r\n2\\. 文档中提到的创意互动类项目，效果都只能在真机上预览，模拟器上暂时都不支持。\r\n\r\n 总结一下：\r\n\r\n1\\. 微信小程序中，官方推出的 threejs 适配版，可以渲染很多 3D 能力，但是若要渲染 VR 全景图，还是需要使用 webview 的能力。\r\n\r\n2\\. 淘宝小程序只能使用 layaair 来实现，对不熟悉此游戏库的开发来说门槛比较高，并不是很通用。\r\n"}]